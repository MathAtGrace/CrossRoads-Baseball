---
title: "Crossroads Baseball Project."
author: "Levi Cain, Kara Godsey, and Dr. Ryan Johnson"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    #highlight: kate
---


```{r setup, echo=FALSE, cache=FALSE}
suppressWarnings(library(knitr))
suppressWarnings(library(rmdformats))

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


# Welcome
Welcome to our student research project.  This project is still in its beginning stages.  The current plan is to rank players and predict games.

### Update 2/12/2020
We have scraped data from the website, although the strictly-conference level data is still elluding us.  To view our process go to "Scraping the Data" on the left-hand side of your screen.

---

# Scraping the Data

For this project we used the NAIA statistics posted on the website [dakstats](http://www.dakstats.com/websync/Pages/Association.aspx?association=10).  They have batting, pitching, and fielding statitistics for each baseball team in the Crossroads league, of which Grace College is a member.

We found the `rvest` R package to be very useful for this project.

```{r}
suppressWarnings(library(rvest))
```

## The Webpage Url's

Dakstats assigns each team an identification number, and uses this number in their webpage urls.  We've created 2-4 letter abreviations for each team, and named them by their ID numbers.

```{r teams-and-urls}
teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784)
urls <- paste0("http://www.dakstats.com/WebSync/Pages/Team/IndividualStats.aspx?association=10&sg=MBA&conference=NAIMBA1_CROSS&team=",names(teams),"&sea=NAIMBA_2019")
```
## Scraping the tables using the `rvest` package

Then we created functions to retrieve only the batting, pitching, and fielding tables, which we turned into data frames in R.

```{r retrieval-functions}
get_batting <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[37]] %>%
    html_table(fill = TRUE)
}

get_pitching <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[38]] %>%
    html_table(fill = TRUE)
}

get_fielding <- function(url) {
  bpf <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[[39]] %>%
    html_table(fill = TRUE)
}
```

We used the `lapply` R function with these functions to get our data.

```{r lapply-it}
Batting <- lapply(urls, get_batting)
names(Batting) <- teams
Pitching <- lapply(urls, get_pitching)
names(Pitching) <- teams
Fielding <- lapply(urls, get_fielding)
names(Fielding) <- teams
```

## Saving the data

And put all of our data into one list.

```{r}
baseball <- list(Batting, Pitching, Fielding)
names(baseball) <- c("Batting", "Pitching", "Fielding")
```
Then we wrote a function to write all of the tables into csv files,

```{r writeit}
#A function to write the data to csv files
writeit <- function(x) {
  #Batting
  write.csv(Batting[[x]], file = paste0("Data/Batting", "/", x, ".csv"))
  #Pitching
  write.csv(Pitching[[x]], file = paste0("Data/Pitching", "/", x, ".csv"))
  #Fielding
  write.csv(Fielding[[x]], file = paste0("Data/Fielding", "/", x, ".csv"))
}
```
and used `lapply` to write the csv's all at once.

```{r write-to-csv}
invisible(lapply(teams, writeit))
```
Lastly, we also saved our data to an Rdata file for our own convenience.

```{r saved}
save(baseball, file = "Data/stats_by_type.Rdata")
```

---

# Creating the Park Factor Code

We wanted to be able to adjust our statistics based on the ballpark where the game was played or will be played. We scraped the schedule data from [dakstats](https://www.dakstats.com/WebSync/Pages/Team/TeamSchedule.aspx?association=10&sg=MBA&sea=NAIMBA_2019&team=1679)
using code similar to the code found in Scraping the Data.

```{r schedule_scrape}
library(rvest)


teams <- c("BC","GOC","GRC","HU","INWU","MAR","MVNU","SAU","SFIN","TAYL")
#R lets us rename the indices of vectors.
names(teams) <- c(1629, 1678, 1679, 1688, 1694, 1717, 1736, 1780, 1805, 1784)
  p_effects <- paste0("http://www.dakstats.com/WebSync/Pages/Team/TeamSchedule.aspx?association=10&sg=MBA&sea=NAIMBA_2019&team=", names(teams))
  
  #Function to get schedule of each team and remove blank rows
  
  get_schedule <- function(url){
  tbls_effects <- url %>%
    read_html() %>%
    html_nodes("table") %>%
    .[36] %>%
    html_table(fill = TRUE)
  Team_Schedule <- data.frame(tbls_effects[[1]])
  Team_Schedule <- Team_Schedule[!apply(is.na(Team_Schedule) | Team_Schedule == "", 1, all),]
  }
  
  schedule <- lapply(p_effects, get_schedule)
  names(schedule) <- teams
```

## Park Factor Function

Since we were looking specifically at Crossroads League conference statistics, we wanted to calculate park factor using only conference games. Therefore, we created a new dataframe with only conference games.

Next, because park factor ajdusts based on runs scored at home and runs scored away, we separated home and away games. 

We then put the scores specific to home or away games into a vector.

Finally, we used the lapply to apply the function to each team.
```{r Park_Factor function}
  Park_effects <- function(g){
    
    Team_Schedule <- schedule[[g]]
    Sched <- Team_Schedule["X2"]
    Scores <- c()
    Conf_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE) 
    j=1
    for (i in 1:nrow(Sched)){
    
      if (grepl("*", Sched[[1]][[i]], fixed = TRUE) == TRUE){
        Conf_Games[j,] <- Team_Schedule[i,]
        j = j + 1
      } 
    }
    
    #print(Conf_Games)
    
    #Separate Home games from neutral and away games
    Home_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE)
    
    Away_Games <- data.frame(Date=character(),
                             Opponent=character(), 
                             Location=character(),
                             Score=character(),
                             Result=character(),
                             stringsAsFactors=FALSE)
    
    
    Loc <- Conf_Games["Location"]
  
    w=1
    z=1
    for (k in 1:nrow(Loc)){
      if (is.element("H", Loc[[1]][[k]]) == TRUE){
        Home_Games[w,] <- Conf_Games[k,]
        w = w + 1
      }
      else if (is.element("A", Loc[[1]][[k]]) == TRUE){
        Away_Games[z,] <- Conf_Games[k,]
        z = z + 1
      }
     
    }
    
    #Put Home team score for each game into a vector
      
  
      Scores_H <- Home_Games[["Score"]]
      Scores_A <- Away_Games[["Score"]]
      p=1
      q=1
      c=1
      d=1
      
        Team_Runs_A <- c()
        Team_Runs_H <- c()
        Opp_Runs_H <- c()
        Opp_Runs_A <- c()
        
        for (x in Scores_H){
          
          if (grepl("(", x, fixed = TRUE) == TRUE){
            Opp_Runs_H[d] <- as.integer(substr(x, (regexpr(pattern ='-', x)+1), nchar(x)-4))
            Team_Runs_H[p] <- as.integer(substr(x, 1, (regexpr(pattern ='-', x)-1)))
          }
          else{
            Team_Runs_H[p] <- as.integer(substr(x, 1, (regexpr(pattern ='-', x)-1)))
            Opp_Runs_H[d] <- as.integer(substr(x, (regexpr(pattern ='-', x)+1), nchar(x)))
            
          }
          
          p = p + 1
          d = d + 1
        }
        
        for (r in Scores_A){
          if (grepl("(", r, fixed = TRUE) == TRUE){
            
            Opp_Runs_A[c] <- as.integer(substr(r, (regexpr(pattern ='-', r)+1), nchar(r)-4))
            Team_Runs_A[q] <- as.integer(substr(r, 1, (regexpr(pattern ='-', r)-1)))
            
          }
          else{
            
            Team_Runs_A[q] <- as.integer(substr(r, 1, (regexpr(pattern ='-', r)-1)))
            Opp_Runs_A[c] <- as.integer(substr(r, (regexpr(pattern ='-', r)+1), nchar(r)))
            
          }
          q = q + 1
          c = c + 1
          
        }
       
  
  Park_effect <- ((sum(Team_Runs_H)+sum(Opp_Runs_H))/length(Team_Runs_H))/((sum(Team_Runs_A)+sum(Opp_Runs_A))/length(Team_Runs_A))
      
  }
  
  p_factor <- teams %>%
    lapply(Park_effects)
  names(p_factor) <- teams
```

---

# Finding the Best Players in the Conference

We decided to use weighted runs created plus to determine the best players in the conference. <!-- add reasons why we used this --> 

We started by creating a dataframe that contained only the players with their weighted runs created plus values. 

```{r error=TRUE, best_players_dataframe}
Best_Players <- data.frame(wRC_plus=numeric())

#counter for teams
y = 1


for (x in Batting){
  
  wRC_plus <- c()
  wRC_name <- c()
  wRC_team <- c()
  PA <- c()
  wRC_plus <- x[["wRC_plus"]]
  wRC_name <- x[["Batting"]]
  PA <- x[["PA"]]
  team <- teams[y]
  for (z in wRC_name){
  
  wRC_team <- c(wRC_team, team[z])      
  
  
  }
  
  new.Best_Players <- data.frame(team, wRC_name,  wRC_plus,  PA)
  Best_Players <- rbind(Best_Players, new.Best_Players)
  
  y = y + 1
}
```

Next, we removed missing values, values from players with less than 20 plate appearances, and trivial values that were included in our dataset.

```{r error=TRUE}
#remove NaN values
Best_Players <- Best_Players[complete.cases(Best_Players), ]

#remove Total and Opponents values
Best_Players <- Best_Players[ !(Best_Players$wRC_name %in% c("Opponents:", "Total:")), ]

Best_Players <- Best_Players[order(-Best_Players$wRC_plus),]

#require players to have at least 20 plate appearances
Best_Players <- Best_Players[!(Best_Players$PA < 20),]
```
---
